<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>自动化部署（一） | Dani's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/highlight.css"/><link rel="stylesheet" type="text/css" href="/css/font.css"/><link rel="stylesheet" type="text/css" href="/css/noise.css"/><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/docker/">docker</a><a class="post-tag-link" href="/tags/webhooks/">webhooks</a><a class="post-tag-link" href="/tags/自动化/">自动化</a></div><div class="post-time">2020-11-09</div></div></div><div class="container post-header"><h1>自动化部署（一）</h1></div><div class="container post-content"><blockquote>
<p> <code>webhooks + github + docker</code></p>
</blockquote>
<p>docker使用</p>
<p>Dockerfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10-alpine</span><br><span class="line">  </span><br><span class="line"># 代表生产环境</span><br><span class="line">ENV PROJECT_ENV production</span><br><span class="line"># 许多 package 会根据此环境变量，做出不同的行为</span><br><span class="line"># 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打&gt;包时会写死该环境变量</span><br><span class="line">ENV NODE_ENV production</span><br><span class="line">RUN mkdir /public</span><br><span class="line">ADD . /public</span><br><span class="line">WORKDIR /public</span><br><span class="line">RUN npm install --production</span><br><span class="line">CMD cd /public &amp;&amp; echo &apos;watch file list&apos; &amp;&amp; ls &amp;&amp; npm run dev</span><br><span class="line">EXPOSE 8080root@mydani: ~/github/helloworld 19:26:50</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>FROM</code>: 依赖的镜像image</li>
<li><code>ENV</code>: 环境变量</li>
<li><code>RUN</code>: 运行<code>docker build</code>时执行的命令。每一个<code>RUN</code>都会在image上加一层。所以RUN越少越好。如：<code>RUN cd /public RUN npm install</code> =&gt; <code>RUN cd /public &amp;&amp; npm install</code></li>
<li><code>CMD</code>: 运行<code>docker run</code>时执行的命令。一个Dockerfile只能有一个CMD</li>
</ul>
<p>github的<code>webhooks</code>配置<br><img src="https://raw.githubusercontent.com/poppydani/picBed/master/images/20201109193553.png" alt="webhooks"></p>
<p>payloadURL: 用户git操作时，向此接口推送数据。</p>
<p><code>webhooks</code>服务器接口内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line">var app = express();</span><br><span class="line">let &#123;exec&#125; = require(&apos;child_process&apos;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: false&#125;));</span><br><span class="line">var hostName = &apos;127.0.0.1&apos;;</span><br><span class="line">var port = 80;</span><br><span class="line"></span><br><span class="line">app.post(&apos;/post&apos;, function(req, res) &#123;</span><br><span class="line">  // console.log(&apos;请求参数：&apos;, req.body);</span><br><span class="line">  var data = null;</span><br><span class="line">  try&#123;</span><br><span class="line">    data = JSON.parse(req.body.payload)</span><br><span class="line">  &#125; catch(error) &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  if(data &amp;&amp; data.repository.name === &apos;helloworld&apos;) &#123;</span><br><span class="line">    exec(</span><br><span class="line">      &apos;cd ~/github/helloworld &amp;&amp; git pull origin master &amp;&amp; source ~/server/webhook/deploy.sh&apos;,</span><br><span class="line">      function(err, stdout, stderr) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          console.log(err)</span><br><span class="line">          res.send(err);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(stdout);</span><br><span class="line">        res.send(stdout);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    res.send(&apos;webhook refused&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/webhook&apos;, function (req, res) &#123;</span><br><span class="line">	console.log(&apos;get webhook&apos;);</span><br><span class="line">   res.sendFile( __dirname + &quot;/&quot; + &quot;webhook.js&quot; );</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(port, function() &#123;</span><br><span class="line">  console.log(`服务运行在http://$&#123;hostName&#125;:$&#123;port&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其中<code>~/server/webhook/deploy.sh</code><br>给container取名就能通过name来stop和rm container<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">docker stop core &amp;&amp; docker rm core</span><br><span class="line">docker build -t core .</span><br><span class="line">docker run -itd -p 8080:8080 --name=&quot;core&quot; core</span><br></pre></td></tr></table></figure></p>
<p>到此，向github上push代码就触发webhooks，推送给服务器接口，接口接受到内容，告诉docker重新生成发布服务。</p>
<blockquote>
<p>其他</p>
</blockquote>
<p><code>node server.js</code> 运行接口文件的话，会依赖终端占用，如果终端关闭，接口就被取消掉了。这个问题可以用forever代替。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、安装forever</span><br><span class="line"></span><br><span class="line">npm install forever-g</span><br><span class="line"></span><br><span class="line">2、用forever开启node程序</span><br><span class="line"></span><br><span class="line">forever start xxx.js --port 8000</span><br><span class="line"></span><br><span class="line">3、关闭node程序</span><br><span class="line"></span><br><span class="line">forever stop xxx.js</span><br></pre></td></tr></table></figure></p>
<p>docker删除所有未使用image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br><span class="line"></span><br><span class="line">docker image prune -a -f 　　#-f强制，不需要确认</span><br></pre></td></tr></table></figure></p>
<p>docker删除未运行的container<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1) 删除所有未运行的容器；运行的删除不了</span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">(2) 根据容器的状态删除状态为Exited的容器</span><br><span class="line">docker rm $(docker ps -qf status=exited)</span><br><span class="line"></span><br><span class="line">(3) docker 1.13版本以后，可以使用docker container prune删除孤立的容器</span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"/><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>